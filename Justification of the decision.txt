Justification of the decision

Ниже — краткое обоснование выбранных подходов для решений .py файлов в этом репозитории.
Приоритеты: корректность, линейная/квазилинейная сложность, читаемость.

A. «Сокровища островов пирата Дино».py
- Идея: граф и поиск компонент (DFS/BFS) с учётом ограничений задачи.
- Почему: для связности/достижимости это базовый оптимальный приём O(n + m).
- Компромиссы: минимум структур данных, строгий парсинг входа.

B. «Отпуск Дино и затопление островов».py
- Идея: многоисточниковый BFS для времени «затопления», затем проверка достижимости.
- Почему: BFS естественно считает минимальные времена, итог O(n*m) для сетки.
- Компромиссы: простые структуры, внимательность к границам.

C. «Обогащение контекста».py
- Идея: предобработка (индексация, маппинги) и быстрые ответы на запросы O(1..logN).
- Почему: классический trade‑off «подготовка → быстрые запросы».
- Компромиссы: держим структуры максимально простыми (dict/list).

D. «Минимальное время разрушения платформ».py
- Идея: бинарный поиск по ответу + проверка выполнимости (feasibility).
- Почему: при монотонности ответа получаем O(Check * logR), Check — линейный.
- Компромиссы: аккуратные границы поиска и корректная проверка.

E. «Датацентры».py
- Идея: сделать граф 2‑рёберно‑связным. Находим мосты (Tarjan, DFS), сжимаем по
  немостовым рёбрам в компоненты, строим дерево компонент. Кол-во новых рёбер —
  ceil(L/2), где L — число листов этого дерева; пары — попарная стыковка
  представителей листовых компонент.
- Почему: классическое минимальное усиление рёберной связности; линейно O(n + m).
- Компромиссы: выбираем представителей компонент — это один из корректных минимальных
  наборов, не единственный.

• Чем отличается list, tuple, set, dict?
list — изменяемая упорядоченная последовательность, допускает дубли, доступ по индексу O(1), вставки в конец амортизированно O(1), вставки/удаления в середине O(n). tuple — неизменяемая упорядоченная последовательность, используется для фиксированных наборов, как ключи в dict (если элементы хэшируемы), хранит те же данные компактно; иногда быстрее list для неизменяемых данных. set — неупорядоченное множество уникальных хэшируемых элементов, быстрый in/добавление/удаление ~O(1), используется для проверки принадлежности, пересечения/объединения. dict — отображение ключ→значение, реализовано как хеш-таблица (в современных CPython также сохраняет порядок вставки), операции доступа по ключу ~O(1). Выбор: нужен порядок/дубли — list; фиксированные записи — tuple; быстрые проверки уникальности — set; ассоциативный доступ — dict.
• Как работает @staticmethod, @classmethod, @property?
@staticmethod превращает функцию в метод класса, который не получает ни self, ни cls — это просто функция, помещённая в пространство имён класса (удобно для группировки логики). @classmethod делает метод принимающим класс cls как первый аргумент — полезно для альтернативных конструкторов и когда поведение зависит от класса (подклассов). @property превращает метод в атрибут для чтения: obj.attr вызывает геттер; можно добавить @x.setter и @x.deleter для установки/удаления; удобно инкапсулировать доступ к полю с синтаксисом атрибута.
• Чем is отличается от ==?
== вызывает __eq__ и проверяет логическое равенство значений (контент), is проверяет идентичность объектов — равенство их id() (одна и та же область памяти). Пример: два разных списка с одинаковыми элементами == даст True, а is — False. Для малых immutable объектов (интернирование строк/целых) is иногда возвращает True, но полагаться на это нельзя.
• Что такое GIL и зачем он нужен в Python?
GIL (Global Interpreter Lock) — глобальная блокировка в CPython, гарантирующая, что в любой момент активен только один поток в интерпретаторе. Она упрощает внутреннюю модель управления памятью (в частности — подсчёт ссылок) и делает многие операции над объектами атомарными без сложных блокировок в каждом объекте. Минусы: потоки не дают реального параллелизма для CPU-bound кода; для I/O-bound задач потоки всё ещё полезны, потому что при блокирующем I/O интерпретатор освобождает GIL. Обходы: использовать multiprocessing (процессы), C-расширения, либо альтернативные реализации Python (PyPy, Jython) или распределять работу на внешние сервисы.
• Чем потоки (threading) отличаются от процессов (multiprocessing)?
Потоки (threads) разделяют память одного процесса — лёгкие по созданию, дешевле по переключению контекста; подходят для I/O-bound задач. Но в CPython GIL ограничивает параллелизм для CPU-bound. Процессы (multiprocessing) имеют отдельную память (изолированные адресные пространства), могут выполняться параллельно на разных CPU — хороши для CPU-bound. Минусы процессов — больше накладных расходов на создание и обмен данными (IPC). Выбор зависит от задачи: I/O → потоки/asyncio; CPU → процессы/сборки на C.
• Что такое asyncio, как работает await, event loop?
asyncio — библиотека для асинхронного программирования (кооперативная многозадачность). async def создаёт корутину; await приостанавливает корутину, отдавая управление loop до готовности awaitable (future, корутина, I/O). Event loop — главный планировщик: запускает корутины, обрабатывает события/таймеры/сокеты. Асинхронность достигается без потоков — при долгих ожиданиях (I/O) другие задачи выполняются. Важно: await не создаёт поток — он лишь переключает управление.
• Как работает with open(...) as f? Что такое менеджер контекста?
with использует протокол менеджера контекста: объект с __enter__ и __exit__. При входе выполняется __enter__, результат присваивается переменной после as; при выходе (включая исключения) выполняется __exit__, который может подавить исключение, если вернёт True. Для open() __exit__ автоматически закрывает файл — это гарантирует освобождение ресурса независимо от исключений.
• Что такое __enter__ и __exit__?
Методы, которые реализует менеджер контекста. __enter__ вызывается при входе в with и возвращает объект для as. __exit__(exc_type, exc_value, traceback) вызывается при выходе; если он возвращает True, исключение подавляется. Можно реализовать свои менеджеры вручную или через contextlib.contextmanager (генераторный синтаксис) для удобства.
• Как работает сборщик мусора в Python?
В CPython есть два механизма: подсчёт ссылок (reference counting) — немедленное освобождение объектов при достижении нуля ссылок; и генерационный сборщик циклических ссылок (gc), который периодически ищет цикличные структуры объектов, недостижимые через внешние ссылки, и удаляет их. gc использует поколения (0,1,2) и пороги для запуска сборки; можно управлять через модуль gc (collect, get_objects, disable). Подсчёт ссылок обеспечивает своевременное освобождение ресурсов, но не справляется с циклами, поэтому нужен gc.
• Что такое reference counting?
Метод управления памятью, при котором у каждого объекта хранится счётчик ссылок — количество ссылок на объект. Когда счётчик падает до нуля, объект сразу освобождается. Преимущество — простота и предсказуемость освобождения; недостаток — циклические ссылки (A→B→A) не будут собраны автоматически, поэтому нужен дополнительный GC.
• Что такое weakref и зачем нужен?
weakref — слабая ссылка на объект: она не увеличивает счётчик ссылок, поэтому не препятствует сборке объекта. Полезно для кэширования или реестров, когда нельзя держать сильную ссылку, иначе объект никогда не будет удалён. При удалении объекта слабая ссылка возвращает None/вызывает callback — удобно отслеживать разрушение объектов.
• Объясни try / except / finally.
try выполняет защищённый блок; except обрабатывает исключения (можно несколько блоков except для разных типов), else выполняется если исключений не было, finally всегда выполняется независимо от результата (подходит для очистки ресурсов). Порядок: try→(в случае исключения → соответствующий except), затем else (если нет исключений), затем finally. Если в except/finally бросается новое исключение — оно заменяет старое.
• Чем отличается raise от assert?
raise явно возбуждает исключение (например, raise ValueError("bad")) — используется в продакшн-логике. assert проверяет условие и бросает AssertionError, если условие ложно; однако при запуске интерпретатора с оптимизацией (-O) все assert-выражения удаляются, поэтому их нельзя использовать для проверки инвариантов в продакшне — это инструмент для тестов/разработки.
• Разница между deepcopy и copy.
copy.copy(obj) делает поверхностную копию: создаёт новый внешний объект, но вложенные изменяемые объекты остаются ссылками на те же объекты. copy.deepcopy(obj) рекурсивно копирует все вложенные объекты (создаёт независимую структуру). deepcopy медленнее и может быть проблематичен со сложными объектами (объекты с состоянием, file handles, подключениями) — для них часто нужна ручная логика клонирования или __getstate__/__setstate__.
• Что такое генераторы и итераторы?
Итератор — объект с методами __iter__() и __next__() (или next() в Py2) — возвращает элементы по одному и при истощении бросает StopIteration. Генератор — синтаксический сахар для итератора, создаётся def f(): yield ... или генераторным выражением (x for x in ...). Генераторы ленивы (вычисляют элементы по требованию), хранят своё состояние между вызовами next().
• Как работает yield?
yield приостанавливает выполнение генератора и возвращает значение вызывающему; состояние функции сохраняется (локальные переменные, позиция) до следующего вызова next(). yield позволяет писать ленивые последовательности, корутины (в старом стиле) и pipeline-стиль обработки данных. yield from (см. следующий пункт) упрощает делегирование.
• Что делает yield from?
yield from iterable делегирует подгенератору: упрощает код вместо for x in iterable: yield x, корректно передаёт значения, исключения и .send() в дочерний генератор. Удобно при компоновке генераторов и при реализации корутин в старом стиле.
• Что такое comprehension (list/dict/set)?
Comprehension — компактный способ создания коллекций из итерируемых объектов: [x*2 for x in it if cond], {k:v for ...}, {x for x in ...}. Они часто быстрее, чем эквивалент через явный цикл (меньше Python-байт-кода), и читаемее. Важно: генераторы ((...)) ленивы; list/tuple комприхи строят сразу. Для больших объёмов памяти используйте генераторы.
• Как работает __iter__ и __next__?
__iter__ возвращает итератор (обычно self), __next__ возвращает следующий элемент или бросает StopIteration при завершении. Для поддержки for x in obj объект должен быть iterable (__iter__) — либо явный итератор, либо объект, который возвращает итератор. Реализация своего итератора состоит из написания обоих методов.
• Что делает __call__?
__call__ превращает экземпляр класса в вызываемый объект: obj() вызывает obj.__call__(). Полезно для реализации объектов-функций, фасадов, конфигурируемых вызовов. Часто используется в паттерне «функтор».
• Как работают __str__ и __repr__?
__repr__ — «официальное» строковое представление объекта, должно, если возможно, быть однозначным и пригодным для восстановления объекта (или давать подробную информацию для отладки). __str__ — «читаемое» представление для пользователей (используется print()). Если __str__ отсутствует, Python использует __repr__.
• В чём отличие __init__ и __new__?
__new__ отвечает за создание нового экземпляра (конструктор на уровне класса); он вызывается первым и должен вернуть экземпляр (обычно super().__new__(cls)). __init__ инициализирует уже созданный объект. __new__ нужен для immutable-классов (tuple/str-like), singletons, контроля создания экземпляров.
• Что такое __slots__ и зачем нужны?
__slots__ — декларация списка допустимых атрибутов для экземпляров класса, при использовании которой Python не создаёт __dict__ для каждого экземпляра, а хранит фиксированную структуру атрибутов — экономия памяти и (иногда) повышение производительности. Минусы: нельзя динамически добавлять атрибуты (кроме тех, что объявлены), сложности с множественным наследованием и совместимостью с pickling/другими механизмами.
• Разница между @dataclass и обычным классом.
@dataclass (модуль dataclasses) автоматически генерирует __init__, __repr__, __eq__ и другие методы по полям класса, сокращая шаблонный код. Поддерживает frozen=True (иммутабельность), default values, default_factory, сравнения и порядок. Обычный класс требует ручной реализации этих методов. dataclass удобен для DTO/структур данных.
• Что делает __eq__, __hash__? Как связаны?
__eq__ определяет поведение ==. __hash__ — возвращает хеш-значение для использования объекта как ключа в dict/set. Правило: если объект сравнивается по значению (__eq__ переопределён), __hash__ должен быть совместим с __eq__: если a == b, то hash(a) == hash(b). В Python, если вы переопределяете __eq__ и не определяете __hash__, объект становится unhashable (по умолчанию __hash__ устанавливается в None), чтобы избежать нарушения контрактов хеша.
• Почему set([ [1,2] ]) вызовет ошибку?
Потому что элементы set должны быть хэшируемы (immutable и иметь корректный __hash__); список (list) — изменяемый и не хэшируемый, поэтому попытка положить его в set вызовет TypeError: unhashable type: 'list'. Для подобных случаев используйте tuple (хэшируемый, если внутри тоже хэшируемые элементы).
• Что такое хэшируемость объектов?
Хэшируемый объект имеет фиксированный хеш (__hash__), который не меняется в течение жизни объекта, и его можно использовать как ключ в dict или элемент множества set. Обычно immutable объекты (tuple, str, int) хэшируемы; mutable объекты (list, dict) — нет, потому что изменение содержимого приведёт к несоответствию ключей в хеш-таблице.
• Как работает Python dict внутри (хэш-таблица)?
Современные CPython используют открытую адресацию с хеш-таблицей и алгоритмом разрешения коллизий (perturbation, пробинг), а с Python 3.6+ внутренне использована compact dict-структура, сохраняющая порядок вставки (гарантируется с 3.7). Ключ→значение хранятся в массивах; hash(key) вычисляется и преобразуется в индекс. При коллизии используется последовательный поиск свободной ячейки. Для ускорения и уменьшения расхода памяти dict использует рехэширование при росте/сжатии. Это даёт амортизированное O(1) для вставки/поиска/удаления.
• Почему поиск по dict быстрее, чем в list?
dict использует хеш-таблицу — прямой доступ по ключу с вычислением хэша и индексированием → ~O(1). list при проверке in или поиске проходит элементы линейно → O(n). Поэтому, если нужно частое наличие/поиск по значению, лучше set/dict.
• Что такое MRO (method resolution order)?
MRO — порядок поиска методов/атрибутов в иерархии классов (особенно при множественном наследовании). CPython использует алгоритм C3-linearization, который обеспечивает согласованность (детерминированный линейный порядок, уважающий порядок базовых классов и локальную последовательность). Class.mro() показывает порядок поиска.
• Чем отличается super() в Python 2 и 3?
В Python 3 super() можно вызывать без аргументов внутри метода (например super().method()), и он автоматически подставит класс и экземпляр; в Python 2 требовалось явно писать super(CurrentClass, self).method(). Также поведение при множественном наследовании и MRO одинаковое, но синтаксический сахар в Py3 удобнее.
• Что такое monkey patching?
Изменение/подмена поведения модулей или классов во время выполнения (runtime) — например, присваивание module.func = new_func. Используется в тестах (замена реального вызова мок-объектом), быстрое исправление багов, но опасно в продакшне — может сломать инварианты и усложнить отладку.
• Что делает functools.lru_cache?
Декоратор, реализующий кэширование результатов функции (Least Recently Used cache). Он хранит вычисленные значения по аргументам (ключом выступает хеш-ключ аргументов) и возвращает закэшированный результат при повторных вызовах, что экономит время при дорогих вычислениях. Поддерживает ограничение размера кэша, статистику хитов/мисс и TTL-логику в кастомных решениях.
• Как работает декоратор?
Декоратор — функция, принимающая функцию и возвращающая новую функцию (обёртку), которая может выполнять логику до/после вызова оригинала, кэшировать, логировать и т.д. Синтаксис @decorator над определением функции — эквивалентно func = decorator(func). Важно в обёртке сохранять метаданные оригинальной функции (functools.wraps).
• В чём разница между *args и **kwargs?
*args собирает позиционные аргументы в кортеж; **kwargs собирает именованные аргументы в словарь. При вызове f(*sequence) распаковывает элементы как позиционные аргументы; f(**mapping) распаковывает пары ключ=значение как именованные параметры.
• Что такое аннотации типов?
Механизм добавления метаданных о типах в объявление функций и переменных с помощью синтаксиса def f(x: int) -> str:. В Python это не влияет на исполнение по умолчанию, но их используют статические анализаторы (mypy), IDE, авто-документация. С Python 3.10/3.11 типы стали более гибкими (PEP 484 и последующие), и есть typing/typing_extensions.
• Что делает typing.Optional?
Optional[X] это сокращение для Union[X, None] — обозначает, что значение либо типа X, либо None. Для аннотаций помогает статическому анализу и читабельности.
• Что значит List[int] vs list[int]?
List[int] — из модуля typing (старый стиль аннотаций) — использовался до Python 3.9; с 3.9 можно писать встроенные параметризуемые типы list[int]. В ранних версиях для параметризации generics использовался typing.List. Для статического анализа оба обозначают список целых чисел, но list[int] — нативный синтаксис современных версий.
• Чем isinstance() отличается от type()?
isinstance(obj, C) проверяет принадлежность к классу C или его подклассам (учитывает наследование). type(obj) is C проверяет точный тип — без учёта наследования. Для проверки полиморфизма и интерфейсов лучше isinstance().
• Что такое метаклассы в Python?
Метакласс — класс, который создаёт классы. По сути type — стандартный метакласс; можно определить свой метакласс (наследоваться от type) и переопределить __new__/__init__ для контроля процесса создания классов (изменение атрибутов, регистрация, проверка интерфейсов). Применяются редко — обычно для фреймворков и DSL.
• Что делает __metaclass__?
В Python 3 синтаксис class C(metaclass=Meta): указывает метакласс Meta, который будет вызван при создании класса C. В Python 2 использовалось атрибут __metaclass__. Метакласс позволяет модифицировать поведение создания класса.
• Разница между старым и новым стилем классов (Python 2 vs 3).
В Python 2 были «старые» и «новые» классы (новые наследовали от object), поведение MRO и super отличалось. В Python 3 все классы — новые, поведение super() и MRO стабилизировано (C3). Уже неактуально в Py3, но полезно знать исторически.
• Что такое “утечка памяти” в Python?
Ситуация, когда объекты остаются доступными (или считаются доступными GC) и не освобождаются, приводя к росту использования памяти. Причины: глобальные структуры, кэши без очистки, циклические ссылки с finalizer'ами (__del__), регистры, слепые подписки на callback'и и пр. Для выявления используйте gc, objgraph, профайлер памяти.
• Как профилировать код на Python (timeit, cProfile)?
timeit — для микробенчмарков (коротких сниппетов), измеряет среднее время выполнения. cProfile — сборка статистики по времени для функций в программе (call counts, cumulative time). Есть визуализаторы (snakeviz, pyinstrument, pprof-аналогии), и инструменты для памяти (tracemalloc, memory_profiler). Подход: сначала cProfile, потом оптимизировать "горячие" функции и профилировать снова.
• Что быстрее: "".join(list) или конкатенация через +? Почему?
"".join(list_of_strings) обычно быстрее и экономнее по памяти, потому что делает одну предварительную аллокацию необходимого размера и копирует строки один раз. Конкатенация через + в цикле для многих элементов приводит к множественным аллокациям и копированию (O(n^2) поведение при naively s += x в цикле). В современных CPython есть оптимизации для += с локальными строками, но join — безопасный и идиоматичный способ.
• Как работает global и nonlocal?
global указывает, что имя относится к глобальной области видимости (модуль), а не к локальной переменной функции; позволяет присваивать глобальной переменной внутри функции. nonlocal (Python 3) указывает, что имя относится к ближайшей внешней (но не глобальной) области видимости (enclosing scope) — позволяет изменять переменные внешней функции из вложенной.
• Что такое замыкания (closure)?
Замыкание — функция, у которой есть доступ к переменным внешней области видимости даже после того, как та внешняя функция завершила выполнение; эти захваченные переменные сохраняются в __closure__. Замыкания удобны для реализации фабрик функций и приватных состояний.
• В чём разница между map/filter/reduce и comprehension?
map/filter возвращают итераторы (в Py3) и применяют функцию ко всем элементам, reduce (из functools) аккумулирует результат. Comprehensions — более читаемые, локальны синтаксически и обычно быстрее за счёт оптимизаций интерпретатора. Comprehensions лучше читаемы и воспринимаемы командой; map/filter удобны для простых однотипных трансформаций и когда нужен ленивый итератор.
• Чем отличаются threading.Lock, RLock и Semaphore?
Lock — простая взаимная блокировка (mutex) — один владелец; RLock (reentrant lock) позволяет одному потоку захватывать lock несколько раз (счётчик), полезно если рекурсивно вызываемые методы требуют той же блокировки. Semaphore(n) ограничивает количество одновременно работающих потоков до n — используется для контроля доступа к ограниченным ресурсам. Также есть Condition, Event и т.д. для синхронизации.
• Что делает asyncio.gather?
asyncio.gather(*aws, return_exceptions=False) запускает несколько awaitable параллельно и собирает их результаты в кортеж в порядке передачи аргументов. Если return_exceptions=False (по умолчанию), если какой-то awaitable бросает исключение, gather эту ошибку поднимет; с return_exceptions=True исключения будут возвращены как объекты в соответствующих позициях. gather удобен для запуска множества корутин и ожидания всех результатов.
• Найти два числа в массиве, сумма которых равна N.
Один из быстрых подходов — hash map: проходите массив один раз, для каждого числа x проверяете, встречался ли target - x в словаре (value→index). Если да — нашли пару. Время O(n), память O(n). Альтернатива для отсортированного массива — два указателя (left, right) двигаются в сторону друг друга, время O(n), память O(1).
• Найти подстроку в строке. Какие алгоритмы знаешь?
Наивный алгоритм (O(n*m)), алгоритм Кнута–Морриса–Пратта (KMP) — O(n+m) с префикс-функцией, Z-функция (также O(n+m)), алгоритм Бойера–Мура (эффективен в практике благодаря сдвигам), Rabin-Karp (хорош для нескольких шаблонов с rolling hash, ожидаемое время O(n+m) с низким риск-колосса хэша). Выбор зависит от требований: worst-case время, практическая производительность и память.
• Чем отличается наивный поиск подстроки от KMP?
Наивный перебирает все возможные позиции и сравнивает по символу — в худшем случае O(n*m). KMP использует префикс-функцию (π) для знания, сколько символов можно «перескочить» при несовпадении — позволяет избежать полного возврата в начало шаблона и даёт O(n+m) в худшем случае.
• Что такое Z-функция и префикс-функция?
Z-функция (Z[i]) строки s — максимальная длина префикса строки, который совпадает с суффиксом, начинающимся в i. Полезна для поиска подстрок и некоторых задач на строки. Префикс-функция (π) для позиции i — длина наибольшего собственного префикса, который является суффиксом префикса s[:i+1] — используется в KMP.
• Задача “скобочная последовательность” — как проверить правильность?
Простой стековый алгоритм: проход по строке, при открывающей скобке — push, при закрывающей — проверяем верх стека на соответствие паре; если не соответствует или стек пуст — некорректно; после прохода стек должен быть пуст. Время O(n), память O(n) в худшем случае.
• Как найти пересечение двух отсортированных массивов?
Два указателя: i=0, j=0; пока оба указателя в границах, если a[i]==b[j] — добавить элемент и инкрементировать оба; если a[i]<b[j] — i+=1, иначе j+=1. Время O(n+m), память — O(1) или O(k) для результата.
• Сложность бинарного поиска?
О(log n) по времени для поиска в отсортированном массиве; O(1) по памяти (итеративная реализация). Важно корректно реализовать границы и избежать overflow при вычислении mid (в Python overflow не проблема).
• Реализуй бинарный поиск.
Классическая реализация: lo=0; hi=len(arr)-1; while lo<=hi: mid=(lo+hi)//2; if arr[mid]==x: return mid; elif arr[mid]<x: lo=mid+1; else: hi=mid-1; return -1. Учитывайте варианты поиска первой/последней позиции (lower_bound/upper_bound).
• Как работает сортировка слиянием?
Разделяй и властвуй: рекурсивно делим массив пополам до единичных массивов, затем сливаем два отсортированных подмассива линейно (O(n)). Время O(n log n) в худшем и среднем случае, стабильна, требует O(n) дополнительной памяти (при оптимизациях можно уменьшить). Подходит для внешней сортировки и связных списков.
• Чем отличается быстрая сортировка от сортировки кучей?
QuickSort (быстрая) — среднее время O(n log n) но худший O(n^2) (если плохой pivot); на практике очень быстра и локальностью. HeapSort — всегда O(n log n) в худшем случае, но хуже локальность и константы; не стабильна. QuickSort обычно быстрее на реальных данных; HeapSort гарантирует худший случай.
• Сложность сортировки вставками?
O(n^2) в худшем случае, O(n) в лучшем (если массив почти отсортирован). Хороша для маленьких массивов и как инсертация в гибридных алгоритмах (например, intro sort/TimSort).
• Как работает heap / приоритетная очередь?
Heap — бинарная куча (min-heap или max-heap) реализуется как массив, где для узла i его дети в индексах 2i+1 и 2i+2; вставка и извлечение минимума выполняются за O(log n) (просеивание вверх/вниз). В Python есть heapq для min-heap. Приоритетная очередь используется для Dijkstra, планирования задач и т.д.
• Что такое hash collision? Как её решать?
Коллизия — два разных ключа дают одинаковый хеш-модуль-размера таблицы. Решения: chaining (цепочки — список элементов в одной корзине), open addressing (поиск следующей свободной позиции по пробинг-схеме), использование качественной хеш-функции, увеличение размера таблицы для уменьшения нагрузки. В Python используется open addressing с размерами и рехэшированием.
• Что такое открытая адресация?
Метод разрешения коллизий в хеш-таблицах: если ячейка занята, вычисляется следующая позиция по некоторой функции (например, линейный/квадратичный пробинг, или perturbation в CPython) и поиск продолжается до свободной ячейки. В отличие от chaining, элементы лежат в массиве, что даёт хорошие кеш-поведения, но сложнее при удалении и требует рехэширования.
• Разница между BFS и DFS.
BFS (breadth-first search) исследует граф по уровням — использует очередь, находит кратчайшие пути в невзвешенных графах по числу ребер; DFS (depth-first search) уходит в глубину — использует стек/рекурсию; полезен для топологической сортировки, поиска компонент и циклов. Различаются порядком обхода и применимыми задачами.
• Сложность BFS?
O(V+E) для графа (вершины+ребра), где каждая вершина и ребро посещаются один раз. Память — O(V) для очереди и visited-структуры.
• Как проверить связность графа?
Запустить DFS или BFS из произвольной вершины; если после обхода все вершины посещены — граф связен (для неориентированного). Для ориентированного графа проверка сильной связности требует алгоритма типа Kosaraju или Tarjan.
• Что такое topological sort?
Топологическая сортировка — упорядочение вершин ориентированного ациклического графа (DAG) так, чтобы для каждого ребра u→v u шло раньше v. Реализуется через DFS с выпуском вершин в обратном порядке или Kahn’s algorithm (удаление вершин с нулевой входной степенью). Используется для планирования задач с зависимостями.
• Как работает алгоритм Дейкстры?
Алгоритм находит кратчайшие пути от источника до всех вершин в графе с неотрицательными весами: используем приоритетную очередь (heap), инициализируем расстояния ∞, distance[src]=0; извлекаем минимальную вершину, релаксация её рёбер (обновление соседей), помещаем обновлённые расстояния в очередь. Сложность O((V+E) log V) с heap-реализацией.
• Чем отличается Дейкстра от Беллмана-Форда?
Дейкстра требует неотрицательных весов (иначе может давать неверные результаты), быстрее: O(E log V) с heap. Беллман-Форд поддерживает отрицательные веса, обнаруживает отрицательные циклы, но медленнее: O(V*E). Выбор зависит от наличия отрицательных весов и требований.
• Что такое A* алгоритм?
A* — поиск пути с эвристикой: использует стоимость f(n)=g(n)+h(n), где g — уже пройденная стоимость, h — эвристическая оценка оставшейся стоимости до цели (должна быть допустимой/не переоценивающей). Если h адекватна (admissible), A* гарантирует оптимальный путь и часто быстрее Dijkstra, так как фокусируется на направлении к цели.
• Как найти минимальное остовное дерево? (Крускал, Прим).
Kruskal: сортируем все ребра по весу, добавляем ребра в остов, если они не образуют цикл (используем union-find), пока не получим V-1 ребро. Prim: начинаем с одной вершины и на каждом шаге добавляем минимальное ребро, ведущее к ещё не включённой вершине (используется heap). Оба дают MST; Kruskal удобен для разреженных графов, Prim — эффективен с adjacency-heap.
• В чём разница между деревом и графом?
Дерево — связный ациклический неориентированный граф. Для дерева с V вершинами ровно V-1 ребро. Граф — более общее понятие: может быть ориентированным/неориентированным, иметь циклы, быть несвязным.
• Что такое бинарное дерево поиска (BST)?
BST — дерево, где для каждой вершины все ключи в левом поддереве меньше ключа вершины, а в правом — больше (или >=/<= в зависимости от соглашения). Позволяет быстрый поиск/вставку/удаление в среднем O(log n), но худший случай O(n) (при вырожденном дереве). Балансировка (AVL, RB-tree) нужна для гарантии логарифмической глубины.
• Чем отличается AVL-дерево от красно-чёрного дерева?
Оба — самобалансирующие BST. AVL-дерево более строго балансируется (разница высот поддеревьев ≤1), даёт более быстрые поиска (меньшая высота), но требует больше вращений при вставке/удалении. Красно-чёрное дерево менее строгое (высота ≤ 2*log(n)), обеспечивает меньшее количество вращений и часто используется в стандартных библиотеках (например, TreeMap в Java) из-за лучшего баланса вставок/удалений.
• Что такое Trie (префиксное дерево)?
Trie — древовидная структура для хранения множества строк, где путь от корня до узла соответствует префиксу. Позволяет поиск, автодополнение и подсчёт префиксных совпадений за O(length_of_key) независимо от количества строк. Минусы — высокая память при большом алфавите; можно оптимизировать с помощью compressed trie (radix tree).
• Как работает структура данных Union-Find?
Union-Find (Disjoint Set Union, DSU) поддерживает операции find(x) (найти репрезентативный элемент множества) и union(a,b) (объединить два множества). С оптимизациями union by rank и path compression сложность почти константная амортизированно (~α(n), где α — обратная функция Аккермана). Часто используется в Kruskal и задачах связности.
• Что такое Fenwick tree (BIT)?
Fenwick tree — структура для эффективного вычисления префиксных сумм и точечных обновлений в массиве за O(log n) на операцию. Компактнее segment tree, проще в реализации, но не подходит для всех типов запросов (например, не поддерживает диапазонные обновления без дополнительной магии).
• Что такое Segment tree?
Segment tree — дерево над диапазонами массива, позволяющее выполнять запросы по диапазону (sum/min/max/gcd) и обновления за O(log n). Можно поддерживать ленивые (lazy) обновления для диапазонных модификаций. Подходит для многих задач с диапазонными запросами.
• Задача: найти k-й по величине элемент в массиве.
Quickselect (вариант QuickSort) позволяет найти k-й порядок statistic за ожидаемое O(n) время: выбирается случайный pivot, разделяем массив на <, =, > pivot и рекурсивно идём в нужную часть. Альтернативы: строить кучу размера k (min-heap для k больших элементов) — O(n log k).
• Как работает quickselect?
Как QuickSort, но рекурсивно обрабатываем только ту часть, где находится k-й элемент: разделяем по pivot; если размер левой части ≥ k, ищем там, если же k в правой части — ищем в правой, иначе найден. На случайном pivot ожидаемое O(n), худшее O(n^2) при плохом выборе pivot.
• Чем отличаются stack и queue?
Stack — LIFO (последним добавлен — первым удалён) — push/pop. Queue — FIFO (первым добавлен — первым удалён). В Python для deque (collections.deque) обе структуры выполняются эффективно; list неэффективен для queue при pop(0).
• Чем deque отличается от queue?
collections.deque — двунаправленная очередь, поддерживает добавление/удаление с обоих концов за O(1). queue.Queue — потокобезопасная структура из модуля queue с блокирующими операциями (put/get) и встроенной синхронизацией, полезна в многопоточном окружении. Выбирай deque для однопоточных задач или когда нужна высокая производительность; queue.Queue — для producer-consumer в потоках.
• В чём сила bloom filter?
Bloom filter — битовый фильтр с несколькими хеш-функциями, служит для проверки: «элемент, возможно, в множестве» или «точно не в множестве». Плюс: очень экономное по памяти представление; минус: ложноположительные ответы возможны (но не ложноотрицательных). Используется в кэшах, базах данных и системах масштабирования для быстрой проверки наличия.
• Что такое LRU cache? Как его реализовать?
LRU (Least Recently Used) — кэш, вытесняющий наименее недавно использованный элемент при переполнении. Реализация: связанный список + hash map (словарь) для O(1) операций get/put; в Python functools.lru_cache обеспечивает это для функций. Можно реализовать через collections.OrderedDict (перемещать ключи в конец при доступе) или вручную.
• Что быстрее: поиск в list или в set?
Поиск (in) в set — ~O(1) среднее время (хеширование), в list — O(n) линейный. Для частых проверок на принадлежность многократно выгоднее set. Если важен порядок — можно использовать list + set совместно.
• В чём отличие динамического программирования от жадного алгоритма?
ДП (dynamic programming) строит решение, запоминая результаты подзадач (мемоизация/табличное заполнение), подходит когда есть оптимальная подструктура и перекрывающиеся подзадачи. Жадный алгоритм делает локально оптимальный выбор и надеется, что это даёт глобально оптимальное решение; он проще и быстрее, но требует доказательства корректности (математическое доказательство жадности). Если доказуемо, жадный часто предпочтительнее.
• Классическая задача ДП: размен монет. Объясни.
Задача: сколько способов разменять сумму N набором монет? Модель: таблица dp[i] — число способов получить сумму i; итерация по монетам: для каждой монеты c для i=c..N делаем dp[i] += dp[i-c]. Это решение O(N * m) (m — число номиналов). Также есть задача минимального числа монет — решается похожим DP (минимизация).
• Что такое мемоизация?
Техника кеширования результатов функции при повторных вызовах (обычно для рекурсивных вычислений), чтобы избежать повторной работы. Результаты сохраняют по ключу аргументов; в Python удобно functools.lru_cache или ручной словарь. Мемоизация превращает экспоненциальные рекурсивные алгоритмы в полиномиальные.
• Как работает Floyd-Warshall?
Алгоритм для поиска кратчайших путей между всеми парами вершин в графе (матрица смежности), динамическое программирование: для каждого промежуточного узла k обновляем dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]). Сложность O(n^3). Подходит для плотных графов и вычисления всех паровых расстояний; обнаруживает отрицательные циклы.
• Что такое транзакция?
Набор операций, которые выполняются атомарно: либо все выполняются и коммитятся, либо при ошибке — откатываются. Транзакция обеспечивает свойства ACID: Atomicity, Consistency, Isolation, Durability. В базах критична для целостности данных при сбоях/конкурентных операциях.
• Как организовать транзакцию в Postgres?
Через BEGIN; ...; COMMIT; / ROLLBACK; или через клиентские библиотеки (в psycopg2 можно использовать with conn: или conn.autocommit=False + conn.commit()/conn.rollback()). В приложении лучше использовать контекстные менеджеры/ORM-транзакции и ретраи при конфликте. Для критичных операций используйте явные уровни изоляции и блокировки (SELECT ... FOR UPDATE) при необходимости.
• Уровни изоляции транзакций.
Стандарт SQL определяет: READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE. Postgres поддерживает READ COMMITTED, REPEATABLE READ, SERIALIZABLE (а READ UNCOMMITTED трактует как READ COMMITTED). Чем выше уровень, тем меньше аномалий (фантомные чтения, non-repeatable reads), но тем выше вероятность блокировок/конфликтов и накладные расходы.
• Что такое deadlock?
Ситуация, когда два или более транзакций взаимно блокируют друг друга, ожидая освобождения ресурсов, которые держат друг у друга. Пример: T1 взял ресурс A и ждёт B; T2 взял B и ждёт A. Для решения — механизм обнаружения циклов блокировок и откаты (DBMS обычно обнаруживает и откатывает одну из транзакций), а также проектирование с упорядоченным захватом ресурсов или таймаутами для избегания.
• Как избежать deadlock?
Практики: всегда захватывать ресурсы в согласованном порядке; держать транзакции короткими; использовать более низкие уровни изоляции; использовать SELECT FOR UPDATE осмотрительно; повторные попытки (retry) на ошибку deadlock; применять таймауты на блокировки.
• Что такое индекс? Зачем нужен?
Индекс — вспомогательная структура (обычно B-tree) для ускорения поиска строк по значению столбца. Позволяет выполнить WHERE, ORDER BY, JOIN быстрее, снижая необходимость чтения всей таблицы. Индексы повышают скорость чтения, но замедляют вставки/обновления и занимают место.
• Какие бывают индексы в Postgres?
Типы: B-tree (по умолчанию, для большинства операций сравнения), Hash (ограниченное использование), GiST (для пространственных/нетривиальных структур), GIN (для массивов и полнотекстового поиска), BRIN (для очень больших, упорядоченных по физическому расположению данных). Выбор зависит от типа данных и запросов.
• Когда индекс не используется?
Индекс может не использоваться, если селективность низкая (много одинаковых значений), выражение в WHERE не совместимо с индексом (функции на колонках без функционального индекса), при слишком маленьких таблицах (planner предпочитает full scan), или если статистика устарела. Также составной индекс (a,b) не помогает при запросе по b без a (лево-ориентированность).
• Что такое foreign key?
Ограничение, которое обеспечивает ссылочную целостность между таблицами: столбец (или набор) в дочерней таблице ссылается на уникальную/первичную ключ-колонку родительской таблицы. БД гарантирует, что значения соответствуют существующим записям родителя; попытка удаления родителя без каскадного удаления вызовет ошибку или повлечёт каскад в зависимости от настроек (ON DELETE CASCADE/RESTRICT/SET NULL).
• Что быстрее: COUNT(*) или COUNT(id)? Почему?
В SQL стандартно COUNT(*) считает строки, игнорируя значения — оптимизировано СУБД. COUNT(id) считает ненулевые значения id (игнорирует NULL). В Postgres COUNT(*) обычно оптимизирован так же быстро, как COUNT(column) при условии, что column не nullable; если id nullable, COUNT(id) может возвращать меньше, и производительность зависит от планировщика. В целом для подсчёта строк используйте COUNT(*) (семантически правильное и часто оптимизируемое выражение).
